---
title: 上下文工程-AI
date: 2025-10-14
category: 博客
---

## 核心概念

**上下文工程** vs **提示工程**：

| 维度   | 提示工程           | 上下文工程                      |
| ------ | ------------------ | ------------------------------- |
| 焦点   | 单次查询的指令优化 | 整个对话状态管理                |
| 使用者 | 普通用户、开发者   | AI智能体开发人员                |
| 范围   | 当前输入           | 系统指令+工具+外部数据+历史消息 |

**定义**：上下文工程是通过优化LLM可用的整体标记集，克服模型固有约束，持续实现期望结果的技术。

## 有效上下文的关键要素

### 1. 结构化系统提示
**最佳实践**：
```xml
<system_prompt>
  <role>你是一个专业的编程助手</role>
  <background>
    用户正在开发一个Web应用项目，技术栈包括React和Node.js
  </background>
  <instructions>
    1. 提供简洁明了的代码示例
    2. 解释关键概念但避免冗长
    3. 当不确定时主动询问澄清
  </instructions>
  <tools>
    可使用代码分析、文档查询等功能
  </tools>
</system_prompt>
```

### 2. 精简工具集设计
**问题**：工具过多导致选择困难
**解决方案**：MVP工具原则
- 合并相似功能工具
- 确保每个工具意图明确
- 参数设计无歧义

### 3. 少样本提示优化
**错误做法**：塞满各种边缘案例
**正确做法**：选择多样化、规范化的代表性示例

## 上下文检索策略

### 混合检索模型
**实例**：Claude Code智能体
- **静态上下文**：CLAUDE.md文件直接预加载
- **动态检索**：使用glob、grep等原语实时查找文件
- **优势**：避免陈旧索引，适应变化环境

## 长时程任务管理

### 1. 上下文压缩
**适用场景**：对话接近上下文窗口限制
**流程**：
```
长对话 → 模型自我总结 → 新上下文窗口初始化
```
**关键**：高保真提炼核心信息，最小化性能损失

### 2. 结构化笔记记录
```python
# 伪代码示例
def 处理长任务():
    while 任务未完成:
        执行工作()
        关键笔记 = 提取核心信息()
        保存到外部存储(关键笔记)  # 上下文外存储
        如果需要: 从外部存储加载历史笔记()
```

### 3. 子智能体架构
**分工模式**：
- **主Agent**：高层规划协调（100-500 token）
- **子Agent**：深度技术工作（10000+ token）
- **输出**：精炼摘要（1000-2000 token）

## 技术选型指南

| 任务类型 | 推荐技术   | 理由               |
| -------- | ---------- | ------------------ |
| 对话流   | 压缩       | 保持对话连贯性     |
| 迭代开发 | 结构化笔记 | 明确里程碑管理     |
| 复杂研究 | 多Agent    | 分工协作，深度探索 |
| 代码开发 | 混合检索   | 平衡效率与实时性   |

## 核心原则

1. **最小化原则**：找到最小的高信号标记集
2. **动态性原则**：根据任务进展调整上下文内容
3. **实用性原则**：技术选择以实际效果为导向

## 总结

上下文工程代表了LLM使用方式的根本转变：从单次提示优化转向全生命周期状态管理。随着模型能力提升，关键在于精心管理有限注意力预算内的信息，通过合理的上下文设计最大化期望结果的概率。

---
