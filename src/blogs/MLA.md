---
title: MLA
date: 2025-12-07
category: 面试
---

**MLA (Multi-Head Latent Attention，多头潜在注意力机制)** 是由 **DeepSeek (深度求索)** 在其 **DeepSeek-V2** 模型中提出的一种创新架构。

---

### 1. 背景：显存的瓶颈 (KV Cache)

在理解这些机制的区别前，核心要关注的指标是 **KV Cache（键值缓存）**。
在大模型推理（Generate）阶段，为了避免重复计算，我们会把之前生成的 Token 的 Key 和 Value 矩阵存在显存里。

随着上下文（Context Length）变长、Batch Size 变大，KV Cache 会占用巨大的显存，甚至超过模型权重本身，导致显存不足（OOM）或吞吐量下降。

---

### 2. 演进之路：MHA vs GQA

#### **MHA (Multi-Head Attention，多头注意力)**
*   **机制**：标准的 Transformer 架构。假设有 32 个头（Head），每个头都有自己独立的 $Q, K, V$ 投影矩阵。
*   **KV Cache**：每个头都需要存储独立的 $K$ 和 $V$。
*   **优点**：模型表达能力最强，因为每个头都能捕捉不同的语义信息。
*   **缺点**：**显存占用巨大**。
    *   *公式*：Cache 大小 $\propto$ 层数 $\times$ 头数 $H \times$ 维度 $d$。

#### **GQA (Grouped-Query Attention，分组查询注意力)**
*   **机制**：为了解决 MHA 显存太大的问题，GQA 将 $Q$ 头分成几组，每组共享同一个 $K$ 和 $V$。
    *   例如：32 个 $Q$ 头，每 8 个 $Q$ 共享 1 个 $K, V$。那么实际上只有 4 个 $K, V$ 头。
*   **KV Cache**：显存占用降低为 MHA 的 $1/G$（G为分组比例）。
*   **优点**：显著降低了显存，推理速度快（因为内存带宽需求小）。目前是 LLaMA 3、Mistral 等主流模型的标配。
*   **缺点**：**主要是有损压缩**。因为强行让多个头共享 $K$ 和 $V$，损失了一定的模型表达能力（虽然在很多任务上微乎其微，但理论上限确实降低了）。

---

### 3. MLA (Multi-Head Latent Attention) 的改进

MLA 的核心目标是：**拥有 MHA 的性能（强大的表达能力），同时拥有 MQA/GQA 的推理效率（极小的 KV Cache）。**

它是如何做到的？答案是：**低秩压缩 (Low-Rank Compression) + 矩阵吸收 (Matrix Absorption)。**

#### **改进点一：KV 的低秩压缩 (极致的显存优化)**

在 MHA 中，我们需要存储完整的 $d_{model}$ 维度的 $K$ 和 $V$。
MLA 认为，$K$ 和 $V$ 中包含大量冗余信息。因此，它不直接存储 $K$ 和 $V$，而是将输入的向量投影到一个**低维的潜在向量 (Latent Vector)** 中。

*   **压缩**：输入向量 -> 下投影矩阵 ($W_{DKV}$) -> **压缩的潜在向量 $C_{KV}$**。
*   **还原**：压缩的潜在向量 $C_{KV}$ -> 上投影矩阵 ($W_{UKV}$) -> 恢复成多头的 $K$ 和 $V$。

**关键的“魔法”在于推理阶段：**
如果我们只是压缩再还原，那显存里还是要存还原后的 $K$ 和 $V$ 吗？**不需要！**

利用矩阵乘法的结合律，MLA 将“还原矩阵 ($W_{UKV}$)”**吸收**到了 Query ($Q$) 的投影矩阵中。
*   **原本的 Attention**： $Q \times K^T$
*   **MLA 的逻辑**： $Q \times (C_{KV} \times W_{UKV})^T = (Q \times W_{UKV}^T) \times C_{KV}^T$

**结果**：我们在推理时的 KV Cache 只需要存储那个**极小的压缩向量 $C_{KV}$**。
这使得 MLA 的 KV Cache 大小极小（通常甚至比 MQA 还要小，或者是 GQA 的几分之一），但它在数学上等价于拥有很多个头，因此保留了 MHA 的多头能力。

#### **改进点二：Decoupled RoPE (解耦的位置编码)**

这是 MLA 为了配合上述压缩策略必须做的改进。
通常的 RoPE（旋转位置编码）是直接作用在 $K$ 上的。如果 $K$ 被 RoPE 旋转了，矩阵的相对关系就被破坏了，上面的“矩阵吸收”技巧就失效了（因为旋转是非线性的或者说无法简单合并进投影矩阵而不影响相对位置）。

**MLA 的解决方案**：
它把 $K$ 分成了两部分：
1.  **内容部分 (Content Part)**：参与低秩压缩，**不加 RoPE**。这部分负责语义，享受极致压缩。
2.  **位置部分 (RoPE Part)**：单独保留一个小向量，**加 RoPE**。这部分负责携带位置信息。

在计算 Attention Score 时，分别计算这两部分的注意力再相加。
虽然这听起来增加了一点计算量，但因为 RoPE 部分的维度很小，增加的计算量微乎其微，却换来了“内容部分”可以被大幅压缩的巨大红利。

---

### 4. 总结：MLA vs MHA vs GQA 详细对比

| 特性              | MHA (传统)      | GQA (主流优化)                | MLA (DeepSeek-V2)                                 |
| :---------------- | :-------------- | :---------------------------- | :------------------------------------------------ |
| **KV Cache 大小** | **极大** (瓶颈) | **中等/小** (约为 MHA 的 1/8) | **极小** (通常优于 MQA，约为 MHA 的 1/50 - 1/100) |
| **显存占用**      | 高              | 低                            | **极低**                                          |
| **模型性能**      | **最强** (无损) | 略有损耗 (参数共享导致)       | **强** (理论上优于 GQA，接近 MHA)                 |
| **原理核心**      | 独立多头        | 强制多头共享 KV               | **低秩压缩 + 矩阵运算结合律**                     |
| **推理技巧**      | 无              | 减少读取量                    | **吸收 Projection 矩阵，只存压缩隐变量**          |

### 5. 通俗类比

*   **MHA (富二代)**：每次出门旅行（推理），给每个朋友（Head）都单独开一辆车（存完整的 KV）。队伍庞大，极其耗油（显存），但在路上每个朋友都能独立看风景（性能好）。
*   **GQA (拼车族)**：为了省油，强行规定每 8 个朋友必须挤同一辆车（共享 KV）。油省了（显存小了），但有些朋友想去别的地方就不行了（自由度下降，性能略损）。
*   **MLA (压缩胶囊)**：DeepSeek 发明了一种技术。出门前把所有人的行李和需求压缩成一个小胶囊（Latent Vector）。
    *   到了目的地（计算 Attention）时，不需要把胶囊还原成原本的车队。
    *   而是让目的地（Query）戴上一副特制的眼镜（吸收了 Up-projection），透过眼镜看这个胶囊，就能直接看到原本那几十辆车队的信息。
    *   **结果**：口袋里只装了一个胶囊（显存极小），但看到的却是完整的豪华车队（性能不降）。

### 结论

MLA 的改进在于它打破了“显存大小”与“模型性能”之间的权衡（Trade-off）。
**相比 GQA，MLA 在使用更少显存（KV Cache）的情况下，提供了更强的模型表达能力（类似于 MHA）。**

这也解释了为什么 DeepSeek-V2 作为一个 MoE 模型，能够在保持极高推理速度和极低推理成本的同时，在长上下文任务和复杂逻辑任务中表现出色。